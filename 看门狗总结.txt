1, 看门狗在什么情况下用？？？



2，看门狗是异常的时候才用，问题是你已经知道了是异常，而不是处理检测不到的那些异常，那么，看门狗对应的功能更准确的来说是复位，那么什么情况下要复位？？？



3，看门狗是怎么实现的复位的？？？看门狗实现复位的原理？？？单片机实现复位的原理是什么？？？

看门狗就是个技数器，在STM32中。
单片机中的复位是个输入引脚，按下这个引脚后单片机就会复位。
按下复位按钮后，板子会自动启动，Linux板子实践的结果就是这样，这个是硬件的原理。


4，面试官：看门狗的原理是什么？？？看门狗的本质是什么？？？
看门狗的原理是个计数器，计数到时，




5，什么是喂狗   ？？？
在以前的理解：喂狗就是复位。  ×××
现在的理解：喂狗举例如下：
给计数器装载值为1000，然后计数器开始自减，在计数器减小值在0之前重新加载计数器的值为1000，然后再次减小，这个过程就叫喂狗。√√√

百度百科：
看门狗定时器(Watchdog Timer ,看门狗)电路一般有一个输入,这个输入被称作"喂狗".

MCU 正常工作的时候，每隔一段时间输出一个信号到喂狗端，给 WDT 清零。如果超过规定的时间不喂狗(一般在程序跑飞时)，WDT 定时超过，就会给出一个复位信号到MCU，让MCU 复位，防止MCU 死机。

看门狗需要在规定时间内喂狗，这里所说的“规定时间”就是看门狗定时器计数溢出时间，即一旦到达计数阈值，看门狗就会产生复位信号。CPU必须在这个周期内对这个定时器进行清零处理，让看门狗定时器重新计数，防止看门狗产生复位信号。



6，看门狗的测试脚本   ？？？

# cat wdt.sh 
#!/bin/sh

cnt=1
while [ $cnt -le $1 ] ; do
        let "cnt++"
        echo 1 > /dev/watchdog
        sleep 15
done

7，关键是结合程序怎么用？？？思路是什么？？？

看门狗就是一个计数器，正常的情况下是不能让它溢出的，所以在程序上每隔一段时间要给他置一次值（俗称喂狗），只要程序中正常给它喂他就不会溢出。一旦程序跑飞了，有干扰或者进入死循环之类的情况时，不能正常执行程序了，那么就永远执行不到喂狗的指令了，但此时定时器是硬件控制的，仍然会走，所以溢出了，单片机就复位了。


7，程序中看门狗的程序放在哪里？？？

程序跑飞或者进入死循环，进入死循环即不停的在一个地方执行，那么程序跑飞是不是也是一直在一个地方执行 ？？？

定时器是独立于CPU的，是时刻都在运行的，那么即使程序进入死循环，定时器仍然在运行，------重点是喂狗这个动作，这个函数是在main 函数中执行的，如果死循环，或者是程序跑飞，那么，程序是执行不到喂狗函数的，这个时候，定时时间到，单片机就会复位。

7，现在的问题是什么，是看门狗的喂狗函数放在哪里？？？是不是要使用看门狗函数，还得测试一下main 函数走一圈需要多长时间？？？



8，为什么单片机中发明了看门狗？？？

用来防止万一单片机程bai序出错造成重du大损失的。


9，看门狗是不是分软件看门狗和硬件看门狗？？？

是的。

10，软件看门狗和硬件看门狗的区别是什么？？？

硬件看门狗是利用一个定时器电路，其定时输出连接到电路的复位端，程序在一定时间范围内对定时器清零(俗称“喂狗”)，因此程序正常工作时，定时器总不能溢出，也就不能产生复位信号。如果程序出现故障，不在定时周期内复位看门狗，就使得看门狗定时器溢出产生复位信号并重启系统。

软件看门狗原理上一样，只是将硬件电路上的定时器用处理器的内部定时器代替，这样可以简化硬件电路设计，但在可靠性方面不如硬件定时器。

我的理解：硬件看门狗的优点是可靠。

软件看门狗的优点是节省硬件资源。

11，为什么硬件看门狗公家可靠？？？可靠在哪里？？？



12，看门狗参考连接资料：
https://www.sekorm.com/news/42654864.html

13，






